
output/crackme:     file format elf32-i386


Disassembly of section .init:

00001000 <_init>:
    1000:	f3 0f 1e fb          	endbr32
    1004:	53                   	push   %ebx
    1005:	83 ec 08             	sub    $0x8,%esp
    1008:	e8 d3 00 00 00       	call   10e0 <__x86.get_pc_thunk.bx>
    100d:	81 c3 e7 2f 00 00    	add    $0x2fe7,%ebx
    1013:	8b 83 f0 ff ff ff    	mov    -0x10(%ebx),%eax
    1019:	85 c0                	test   %eax,%eax
    101b:	74 02                	je     101f <_init+0x1f>
    101d:	ff d0                	call   *%eax
    101f:	83 c4 08             	add    $0x8,%esp
    1022:	5b                   	pop    %ebx
    1023:	c3                   	ret

Disassembly of section .plt:

00001030 <__libc_start_main@plt-0x10>:
    1030:	ff b3 04 00 00 00    	push   0x4(%ebx)
    1036:	ff a3 08 00 00 00    	jmp    *0x8(%ebx)
    103c:	00 00                	add    %al,(%eax)
	...

00001040 <__libc_start_main@plt>:
    1040:	ff a3 0c 00 00 00    	jmp    *0xc(%ebx)
    1046:	68 00 00 00 00       	push   $0x0
    104b:	e9 e0 ff ff ff       	jmp    1030 <_init+0x30>

00001050 <printf@plt>:
    1050:	ff a3 10 00 00 00    	jmp    *0x10(%ebx)
    1056:	68 08 00 00 00       	push   $0x8
    105b:	e9 d0 ff ff ff       	jmp    1030 <_init+0x30>

00001060 <fgets@plt>:
    1060:	ff a3 14 00 00 00    	jmp    *0x14(%ebx)
    1066:	68 10 00 00 00       	push   $0x10
    106b:	e9 c0 ff ff ff       	jmp    1030 <_init+0x30>

00001070 <puts@plt>:
    1070:	ff a3 18 00 00 00    	jmp    *0x18(%ebx)
    1076:	68 18 00 00 00       	push   $0x18
    107b:	e9 b0 ff ff ff       	jmp    1030 <_init+0x30>

00001080 <strlen@plt>:
    1080:	ff a3 1c 00 00 00    	jmp    *0x1c(%ebx)
    1086:	68 20 00 00 00       	push   $0x20
    108b:	e9 a0 ff ff ff       	jmp    1030 <_init+0x30>

00001090 <snprintf@plt>:
    1090:	ff a3 20 00 00 00    	jmp    *0x20(%ebx)
    1096:	68 28 00 00 00       	push   $0x28
    109b:	e9 90 ff ff ff       	jmp    1030 <_init+0x30>

000010a0 <__ctype_b_loc@plt>:
    10a0:	ff a3 24 00 00 00    	jmp    *0x24(%ebx)
    10a6:	68 30 00 00 00       	push   $0x30
    10ab:	e9 80 ff ff ff       	jmp    1030 <_init+0x30>

Disassembly of section .text:

000010b0 <_start>:
    10b0:	f3 0f 1e fb          	endbr32
    10b4:	31 ed                	xor    %ebp,%ebp
    10b6:	5e                   	pop    %esi
    10b7:	89 e1                	mov    %esp,%ecx
    10b9:	83 e4 f0             	and    $0xfffffff0,%esp
    10bc:	50                   	push   %eax
    10bd:	54                   	push   %esp
    10be:	52                   	push   %edx
    10bf:	e8 18 00 00 00       	call   10dc <_start+0x2c>
    10c4:	81 c3 30 2f 00 00    	add    $0x2f30,%ebx
    10ca:	6a 00                	push   $0x0
    10cc:	6a 00                	push   $0x0
    10ce:	51                   	push   %ecx
    10cf:	56                   	push   %esi
    10d0:	ff b3 f8 ff ff ff    	push   -0x8(%ebx)
    10d6:	e8 65 ff ff ff       	call   1040 <__libc_start_main@plt>
    10db:	f4                   	hlt
    10dc:	8b 1c 24             	mov    (%esp),%ebx
    10df:	c3                   	ret

000010e0 <__x86.get_pc_thunk.bx>:
    10e0:	8b 1c 24             	mov    (%esp),%ebx
    10e3:	c3                   	ret
    10e4:	66 90                	xchg   %ax,%ax
    10e6:	66 90                	xchg   %ax,%ax
    10e8:	66 90                	xchg   %ax,%ax
    10ea:	66 90                	xchg   %ax,%ax
    10ec:	66 90                	xchg   %ax,%ax
    10ee:	66 90                	xchg   %ax,%ax
    10f0:	e8 e4 00 00 00       	call   11d9 <__x86.get_pc_thunk.dx>
    10f5:	81 c2 ff 2e 00 00    	add    $0x2eff,%edx
    10fb:	8d 8a 30 00 00 00    	lea    0x30(%edx),%ecx
    1101:	8d 82 30 00 00 00    	lea    0x30(%edx),%eax
    1107:	39 c8                	cmp    %ecx,%eax
    1109:	74 1d                	je     1128 <__x86.get_pc_thunk.bx+0x48>
    110b:	8b 82 e4 ff ff ff    	mov    -0x1c(%edx),%eax
    1111:	85 c0                	test   %eax,%eax
    1113:	74 13                	je     1128 <__x86.get_pc_thunk.bx+0x48>
    1115:	55                   	push   %ebp
    1116:	89 e5                	mov    %esp,%ebp
    1118:	83 ec 14             	sub    $0x14,%esp
    111b:	51                   	push   %ecx
    111c:	ff d0                	call   *%eax
    111e:	83 c4 10             	add    $0x10,%esp
    1121:	c9                   	leave
    1122:	c3                   	ret
    1123:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    1127:	90                   	nop
    1128:	c3                   	ret
    1129:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    1130:	e8 a4 00 00 00       	call   11d9 <__x86.get_pc_thunk.dx>
    1135:	81 c2 bf 2e 00 00    	add    $0x2ebf,%edx
    113b:	55                   	push   %ebp
    113c:	89 e5                	mov    %esp,%ebp
    113e:	53                   	push   %ebx
    113f:	8d 8a 30 00 00 00    	lea    0x30(%edx),%ecx
    1145:	8d 82 30 00 00 00    	lea    0x30(%edx),%eax
    114b:	83 ec 04             	sub    $0x4,%esp
    114e:	29 c8                	sub    %ecx,%eax
    1150:	89 c3                	mov    %eax,%ebx
    1152:	c1 e8 1f             	shr    $0x1f,%eax
    1155:	c1 fb 02             	sar    $0x2,%ebx
    1158:	01 d8                	add    %ebx,%eax
    115a:	d1 f8                	sar    %eax
    115c:	74 14                	je     1172 <__x86.get_pc_thunk.bx+0x92>
    115e:	8b 92 fc ff ff ff    	mov    -0x4(%edx),%edx
    1164:	85 d2                	test   %edx,%edx
    1166:	74 0a                	je     1172 <__x86.get_pc_thunk.bx+0x92>
    1168:	83 ec 08             	sub    $0x8,%esp
    116b:	50                   	push   %eax
    116c:	51                   	push   %ecx
    116d:	ff d2                	call   *%edx
    116f:	83 c4 10             	add    $0x10,%esp
    1172:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    1175:	c9                   	leave
    1176:	c3                   	ret
    1177:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
    117e:	66 90                	xchg   %ax,%ax
    1180:	f3 0f 1e fb          	endbr32
    1184:	55                   	push   %ebp
    1185:	89 e5                	mov    %esp,%ebp
    1187:	53                   	push   %ebx
    1188:	e8 53 ff ff ff       	call   10e0 <__x86.get_pc_thunk.bx>
    118d:	81 c3 67 2e 00 00    	add    $0x2e67,%ebx
    1193:	83 ec 04             	sub    $0x4,%esp
    1196:	80 bb 30 00 00 00 00 	cmpb   $0x0,0x30(%ebx)
    119d:	75 28                	jne    11c7 <__x86.get_pc_thunk.bx+0xe7>
    119f:	8b 83 ec ff ff ff    	mov    -0x14(%ebx),%eax
    11a5:	85 c0                	test   %eax,%eax
    11a7:	74 12                	je     11bb <__x86.get_pc_thunk.bx+0xdb>
    11a9:	83 ec 0c             	sub    $0xc,%esp
    11ac:	ff b3 2c 00 00 00    	push   0x2c(%ebx)
    11b2:	ff 93 ec ff ff ff    	call   *-0x14(%ebx)
    11b8:	83 c4 10             	add    $0x10,%esp
    11bb:	e8 30 ff ff ff       	call   10f0 <__x86.get_pc_thunk.bx+0x10>
    11c0:	c6 83 30 00 00 00 01 	movb   $0x1,0x30(%ebx)
    11c7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
    11ca:	c9                   	leave
    11cb:	c3                   	ret
    11cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
    11d0:	f3 0f 1e fb          	endbr32
    11d4:	e9 57 ff ff ff       	jmp    1130 <__x86.get_pc_thunk.bx+0x50>

000011d9 <__x86.get_pc_thunk.dx>:
    11d9:	8b 14 24             	mov    (%esp),%edx
    11dc:	c3                   	ret

000011dd <substr>:
#include <stdio.h>
#include <string.h>
#include <ctype.h>

// copy n characters of a string from src to dst. dst will include a NULL-termination
int substr(char *dst, char *src, size_t n) {
    11dd:	53                   	push   %ebx
    11de:	83 ec 08             	sub    $0x8,%esp
    11e1:	e8 fa fe ff ff       	call   10e0 <__x86.get_pc_thunk.bx>
    11e6:	81 c3 0e 2e 00 00    	add    $0x2e0e,%ebx
  int len = snprintf(dst, n, "%s", src);
    11ec:	ff 74 24 14          	push   0x14(%esp)
    11f0:	8d 83 14 e0 ff ff    	lea    -0x1fec(%ebx),%eax
    11f6:	50                   	push   %eax
    11f7:	ff 74 24 20          	push   0x20(%esp)
    11fb:	ff 74 24 1c          	push   0x1c(%esp)
    11ff:	e8 8c fe ff ff       	call   1090 <snprintf@plt>
  if (len < 0 || (unsigned) len >= sizeof dst) return -1;
    1204:	83 c4 10             	add    $0x10,%esp
    1207:	83 f8 03             	cmp    $0x3,%eax
    120a:	77 05                	ja     1211 <substr+0x34>
  return len;
}
    120c:	83 c4 08             	add    $0x8,%esp
    120f:	5b                   	pop    %ebx
    1210:	c3                   	ret
  if (len < 0 || (unsigned) len >= sizeof dst) return -1;
    1211:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    1216:	eb f4                	jmp    120c <substr+0x2f>

00001218 <ok>:

void ok() {
    1218:	53                   	push   %ebx
    1219:	83 ec 14             	sub    $0x14,%esp
    121c:	e8 bf fe ff ff       	call   10e0 <__x86.get_pc_thunk.bx>
    1221:	81 c3 d3 2d 00 00    	add    $0x2dd3,%ebx
  printf("Access granted!\n");
    1227:	8d 83 17 e0 ff ff    	lea    -0x1fe9(%ebx),%eax
    122d:	50                   	push   %eax
    122e:	e8 3d fe ff ff       	call   1070 <puts@plt>
}
    1233:	83 c4 18             	add    $0x18,%esp
    1236:	5b                   	pop    %ebx
    1237:	c3                   	ret

00001238 <not_ok>:

void not_ok() {
    1238:	53                   	push   %ebx
    1239:	83 ec 14             	sub    $0x14,%esp
    123c:	e8 9f fe ff ff       	call   10e0 <__x86.get_pc_thunk.bx>
    1241:	81 c3 b3 2d 00 00    	add    $0x2db3,%ebx
  printf("Access denied!\n");
    1247:	8d 83 27 e0 ff ff    	lea    -0x1fd9(%ebx),%eax
    124d:	50                   	push   %eax
    124e:	e8 1d fe ff ff       	call   1070 <puts@plt>
}
    1253:	83 c4 18             	add    $0x18,%esp
    1256:	5b                   	pop    %ebx
    1257:	c3                   	ret

00001258 <check_serial>:

// valid: 9711-9796-8887-9714
int check_serial(const char* serial, size_t length) {
    1258:	55                   	push   %ebp
    1259:	57                   	push   %edi
    125a:	56                   	push   %esi
    125b:	53                   	push   %ebx
    125c:	83 ec 28             	sub    $0x28,%esp
    125f:	e8 7c fe ff ff       	call   10e0 <__x86.get_pc_thunk.bx>
    1264:	81 c3 90 2d 00 00    	add    $0x2d90,%ebx
  int i, set1 = 0, set2 = 0, set3 = 0, set4 = 0;

  // Verify the serial format: nnnn-nnnn-nnnn-nnnn
  if (strlen(serial) != length) {
    126a:	ff 74 24 3c          	push   0x3c(%esp)
    126e:	e8 0d fe ff ff       	call   1080 <strlen@plt>
    1273:	83 c4 10             	add    $0x10,%esp
    1276:	3b 44 24 34          	cmp    0x34(%esp),%eax
    127a:	0f 85 f0 00 00 00    	jne    1370 <check_serial+0x118>
  int i, set1 = 0, set2 = 0, set3 = 0, set4 = 0;
    1280:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
    1287:	00 
    1288:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
    128f:	00 
    1290:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
    1297:	00 
    1298:	bd 00 00 00 00       	mov    $0x0,%ebp
    return 0; // Incorrect length
  }

  for (i = 0; i < (int) length; i++) {
    129d:	be 00 00 00 00       	mov    $0x0,%esi
    12a2:	eb 36                	jmp    12da <check_serial+0x82>

    if (i == 4 || i == 9 || i == 14) {
      if (c != '-') {
        return 0; // Invalid separator at positions 4, 9, and 14
      }
    } else if (!isdigit(c)) {
    12a4:	e8 f7 fd ff ff       	call   10a0 <__ctype_b_loc@plt>
    12a9:	8b 00                	mov    (%eax),%eax
    12ab:	89 fa                	mov    %edi,%edx
    12ad:	0f be d2             	movsbl %dl,%edx
    12b0:	f6 44 50 01 08       	testb  $0x8,0x1(%eax,%edx,2)
    12b5:	75 49                	jne    1300 <check_serial+0xa8>
      return 0; // Non-numeric characters found
    12b7:	b8 00 00 00 00       	mov    $0x0,%eax
    12bc:	e9 b4 00 00 00       	jmp    1375 <check_serial+0x11d>
    }

    if (i < 4) {
      set1 += c - '0';
    } else if (i < 9) {
    12c1:	83 fe 08             	cmp    $0x8,%esi
    12c4:	7f 4a                	jg     1310 <check_serial+0xb8>
      set2 += c - '2';
    12c6:	89 f8                	mov    %edi,%eax
    12c8:	0f be f8             	movsbl %al,%edi
    12cb:	8b 44 24 04          	mov    0x4(%esp),%eax
    12cf:	8d 44 38 ce          	lea    -0x32(%eax,%edi,1),%eax
    12d3:	89 44 24 04          	mov    %eax,0x4(%esp)
  for (i = 0; i < (int) length; i++) {
    12d7:	83 c6 01             	add    $0x1,%esi
    12da:	39 74 24 34          	cmp    %esi,0x34(%esp)
    12de:	7e 5f                	jle    133f <check_serial+0xe7>
    char c = serial[i];
    12e0:	8b 44 24 30          	mov    0x30(%esp),%eax
    12e4:	0f b6 3c 30          	movzbl (%eax,%esi,1),%edi
    if (i == 4 || i == 9 || i == 14) {
    12e8:	83 fe 0e             	cmp    $0xe,%esi
    12eb:	77 b7                	ja     12a4 <check_serial+0x4c>
    12ed:	b8 10 42 00 00       	mov    $0x4210,%eax
    12f2:	89 f1                	mov    %esi,%ecx
    12f4:	d3 e8                	shr    %cl,%eax
    12f6:	a8 01                	test   $0x1,%al
    12f8:	74 aa                	je     12a4 <check_serial+0x4c>
      if (c != '-') {
    12fa:	89 f8                	mov    %edi,%eax
    12fc:	3c 2d                	cmp    $0x2d,%al
    12fe:	75 7d                	jne    137d <check_serial+0x125>
    if (i < 4) {
    1300:	83 fe 03             	cmp    $0x3,%esi
    1303:	7f bc                	jg     12c1 <check_serial+0x69>
      set1 += c - '0';
    1305:	89 f8                	mov    %edi,%eax
    1307:	0f be f8             	movsbl %al,%edi
    130a:	8d 6c 3d d0          	lea    -0x30(%ebp,%edi,1),%ebp
    130e:	eb c7                	jmp    12d7 <check_serial+0x7f>
    } else if (i < 14) {
    1310:	83 fe 0d             	cmp    $0xd,%esi
    1313:	7f 17                	jg     132c <check_serial+0xd4>
      if (9 == c) {
    1315:	89 f8                	mov    %edi,%eax
    1317:	3c 09                	cmp    $0x9,%al
    1319:	74 69                	je     1384 <check_serial+0x12c>
        return 0;
      }
      set3 += c - '2';
    131b:	0f be f8             	movsbl %al,%edi
    131e:	8b 44 24 0c          	mov    0xc(%esp),%eax
    1322:	8d 44 38 ce          	lea    -0x32(%eax,%edi,1),%eax
    1326:	89 44 24 0c          	mov    %eax,0xc(%esp)
    132a:	eb ab                	jmp    12d7 <check_serial+0x7f>
    } else {
      set4 += c - '0';
    132c:	89 f8                	mov    %edi,%eax
    132e:	0f be f8             	movsbl %al,%edi
    1331:	8b 44 24 08          	mov    0x8(%esp),%eax
    1335:	8d 44 38 d0          	lea    -0x30(%eax,%edi,1),%eax
    1339:	89 44 24 08          	mov    %eax,0x8(%esp)
    133d:	eb 98                	jmp    12d7 <check_serial+0x7f>
  printf("%d\n", set3);
  printf("%d\n", set4);
  */

  // Check the computed sums for each set
  if (set1 != 18 || set2 != 18 || set3 != 18 || set4 != 18) {
    133f:	83 fd 12             	cmp    $0x12,%ebp
    1342:	0f 95 c0             	setne  %al
    1345:	83 7c 24 04 12       	cmpl   $0x12,0x4(%esp)
    134a:	0f 95 c2             	setne  %dl
    134d:	08 d0                	or     %dl,%al
    134f:	75 3a                	jne    138b <check_serial+0x133>
    1351:	83 7c 24 0c 12       	cmpl   $0x12,0xc(%esp)
    1356:	0f 95 c0             	setne  %al
    1359:	83 7c 24 08 12       	cmpl   $0x12,0x8(%esp)
    135e:	0f 95 c2             	setne  %dl
    1361:	84 c0                	test   %al,%al
    1363:	75 2d                	jne    1392 <check_serial+0x13a>
    1365:	84 d2                	test   %dl,%dl
    1367:	75 29                	jne    1392 <check_serial+0x13a>
    return 0; // Invalid sums for sets
  }

  return 1; // Serial is valid
    1369:	b8 01 00 00 00       	mov    $0x1,%eax
    136e:	eb 05                	jmp    1375 <check_serial+0x11d>
    return 0; // Incorrect length
    1370:	b8 00 00 00 00       	mov    $0x0,%eax
}
    1375:	83 c4 1c             	add    $0x1c,%esp
    1378:	5b                   	pop    %ebx
    1379:	5e                   	pop    %esi
    137a:	5f                   	pop    %edi
    137b:	5d                   	pop    %ebp
    137c:	c3                   	ret
        return 0; // Invalid separator at positions 4, 9, and 14
    137d:	b8 00 00 00 00       	mov    $0x0,%eax
    1382:	eb f1                	jmp    1375 <check_serial+0x11d>
        return 0;
    1384:	b8 00 00 00 00       	mov    $0x0,%eax
    1389:	eb ea                	jmp    1375 <check_serial+0x11d>
    return 0; // Invalid sums for sets
    138b:	b8 00 00 00 00       	mov    $0x0,%eax
    1390:	eb e3                	jmp    1375 <check_serial+0x11d>
    1392:	b8 00 00 00 00       	mov    $0x0,%eax
    1397:	eb dc                	jmp    1375 <check_serial+0x11d>

00001399 <main>:

int main() {
    1399:	8d 4c 24 04          	lea    0x4(%esp),%ecx
    139d:	83 e4 f0             	and    $0xfffffff0,%esp
    13a0:	ff 71 fc             	push   -0x4(%ecx)
    13a3:	55                   	push   %ebp
    13a4:	89 e5                	mov    %esp,%ebp
    13a6:	56                   	push   %esi
    13a7:	53                   	push   %ebx
    13a8:	51                   	push   %ecx
    13a9:	83 ec 38             	sub    $0x38,%esp
    13ac:	e8 2f fd ff ff       	call   10e0 <__x86.get_pc_thunk.bx>
    13b1:	81 c3 43 2c 00 00    	add    $0x2c43,%ebx
    13b7:	65 a1 14 00 00 00    	mov    %gs:0x14,%eax
    13bd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    13c0:	31 c0                	xor    %eax,%eax
  printf("\n *** enjoy the crackme ***\n\n");
    13c2:	8d 83 36 e0 ff ff    	lea    -0x1fca(%ebx),%eax
    13c8:	50                   	push   %eax
    13c9:	e8 a2 fc ff ff       	call   1070 <puts@plt>
  int input_n = 21;
  char input[input_n];

  printf("Enter the password: ");
    13ce:	8d 83 53 e0 ff ff    	lea    -0x1fad(%ebx),%eax
    13d4:	89 04 24             	mov    %eax,(%esp)
    13d7:	e8 74 fc ff ff       	call   1050 <printf@plt>
  fgets(input, sizeof(input), stdin);
    13dc:	83 c4 0c             	add    $0xc,%esp
    13df:	8b 83 f4 ff ff ff    	mov    -0xc(%ebx),%eax
    13e5:	ff 30                	push   (%eax)
    13e7:	6a 15                	push   $0x15
    13e9:	8d 75 cf             	lea    -0x31(%ebp),%esi
    13ec:	56                   	push   %esi
    13ed:	e8 6e fc ff ff       	call   1060 <fgets@plt>

  // Remove the newline character if it exists
  size_t length = strlen(input);
    13f2:	89 34 24             	mov    %esi,(%esp)
    13f5:	e8 86 fc ff ff       	call   1080 <strlen@plt>
    13fa:	83 c4 10             	add    $0x10,%esp
  if (input[length - 1] == '\n') {
    13fd:	8d 50 ff             	lea    -0x1(%eax),%edx
    1400:	80 7c 05 ce 0a       	cmpb   $0xa,-0x32(%ebp,%eax,1)
    1405:	74 35                	je     143c <main+0xa3>
    input[length - 1] = '\0'; // Replace newline with null terminator
  }

  // printf("<%s>\n", input);
  if ( check_serial(input, length -1) ) {
    1407:	83 ec 08             	sub    $0x8,%esp
    140a:	52                   	push   %edx
    140b:	8d 45 cf             	lea    -0x31(%ebp),%eax
    140e:	50                   	push   %eax
    140f:	e8 44 fe ff ff       	call   1258 <check_serial>
    1414:	83 c4 10             	add    $0x10,%esp
    1417:	85 c0                	test   %eax,%eax
    1419:	74 28                	je     1443 <main+0xaa>
    ok();
    141b:	e8 f8 fd ff ff       	call   1218 <ok>
  } else {
    not_ok();
  }

  return 0;
}
    1420:	8b 45 e4             	mov    -0x1c(%ebp),%eax
    1423:	65 2b 05 14 00 00 00 	sub    %gs:0x14,%eax
    142a:	75 1e                	jne    144a <main+0xb1>
    142c:	b8 00 00 00 00       	mov    $0x0,%eax
    1431:	8d 65 f4             	lea    -0xc(%ebp),%esp
    1434:	59                   	pop    %ecx
    1435:	5b                   	pop    %ebx
    1436:	5e                   	pop    %esi
    1437:	5d                   	pop    %ebp
    1438:	8d 61 fc             	lea    -0x4(%ecx),%esp
    143b:	c3                   	ret
    input[length - 1] = '\0'; // Replace newline with null terminator
    143c:	c6 44 15 cf 00       	movb   $0x0,-0x31(%ebp,%edx,1)
    1441:	eb c4                	jmp    1407 <main+0x6e>
    not_ok();
    1443:	e8 f0 fd ff ff       	call   1238 <not_ok>
    1448:	eb d6                	jmp    1420 <main+0x87>
}
    144a:	e8 01 00 00 00       	call   1450 <__stack_chk_fail_local>
    144f:	90                   	nop

00001450 <__stack_chk_fail_local>:
    1450:	f3 0f 1e fb          	endbr32
    1454:	56                   	push   %esi
    1455:	5e                   	pop    %esi
    1456:	e8 0e 00 00 00       	call   1469 <__x86.get_pc_thunk.ax>
    145b:	05 99 2b 00 00       	add    $0x2b99,%eax
    1460:	83 ec 0c             	sub    $0xc,%esp
    1463:	ff 90 e8 ff ff ff    	call   *-0x18(%eax)

00001469 <__x86.get_pc_thunk.ax>:
    1469:	8b 04 24             	mov    (%esp),%eax
    146c:	c3                   	ret

Disassembly of section .fini:

00001470 <_fini>:
    1470:	f3 0f 1e fb          	endbr32
    1474:	53                   	push   %ebx
    1475:	83 ec 08             	sub    $0x8,%esp
    1478:	e8 63 fc ff ff       	call   10e0 <__x86.get_pc_thunk.bx>
    147d:	81 c3 77 2b 00 00    	add    $0x2b77,%ebx
    1483:	83 c4 08             	add    $0x8,%esp
    1486:	5b                   	pop    %ebx
    1487:	c3                   	ret
